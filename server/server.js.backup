const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const net = require('net');
const cors = require('cors');
const pokemonData = require('./pokemon-data');

const app = express();
app.use(cors());
app.use(express.json());

const server = http.createServer(app);
const io = socketIo(server, {
  cors: {
    origin: "http://localhost:3000",
    methods: ["GET", "POST"]
  }
});

// Configuration
const TCP_PORT = 17242;
const HTTP_PORT = 3001;

// State
let bizhawkClient = null;
let battleState = null;
let connectionStatus = 'disconnected';

// Create TCP server for BizHawk connection
const tcpServer = net.createServer((socket) => {
  console.log('BizHawk connected');
  bizhawkClient = socket;
  connectionStatus = 'connected';
  
  // Notify all web clients
  io.emit('connection-status', { status: 'connected' });
  
  let buffer = '';
  
  socket.on('data', (data) => {
    buffer += data.toString();
    
    // Parse messages (format: "length json_data")
    while (buffer.includes(' ')) {
      const spaceIndex = buffer.indexOf(' ');
      const length = parseInt(buffer.substring(0, spaceIndex));
      
      if (buffer.length >= spaceIndex + 1 + length) {
        const jsonStr = buffer.substring(spaceIndex + 1, spaceIndex + 1 + length);
        buffer = buffer.substring(spaceIndex + 1 + length);
        
        try {
          const message = JSON.parse(jsonStr);
          handleBizhawkMessage(message);
        } catch (e) {
          console.error('Failed to parse message:', e);
        }
      } else {
        break; // Wait for more data
      }
    }
  });
  
  socket.on('end', () => {
    console.log('BizHawk disconnected');
    bizhawkClient = null;
    connectionStatus = 'disconnected';
    battleState = null;
    io.emit('connection-status', { status: 'disconnected' });
    io.emit('battle-update', null);
  });
  
  socket.on('error', (err) => {
    console.error('TCP Socket error:', err);
  });
});

function handleBizhawkMessage(message) {
  switch (message.type) {
    case 'battle_update':
      battleState = processBattleData(message.data);
      io.emit('battle-update', battleState);
      break;
      
    case 'heartbeat':
      if (message.data && !message.data.in_battle) {
        battleState = null;
        io.emit('battle-update', null);
      }
      break;
      
    case 'disconnect':
      console.log('BizHawk script stopped:', message.data.reason);
      break;
  }
}

function processBattleData(rawData) {
  if (!rawData || !rawData.enemy || !rawData.enemy.active) {
    return null;
  }
  
  const enemyPokemon = rawData.enemy.active;
  const playerPokemon = rawData.player.active;
  
  // Get Pokemon info from data files
  const enemyInfo = pokemonData.getPokemonInfo(enemyPokemon.species);
  const playerInfo = pokemonData.getPokemonInfo(playerPokemon.species);
  
  // Calculate tier rating
  const tierRating = pokemonData.calculateTierRating(enemyPokemon, enemyInfo);
  
  // Calculate type effectiveness
  const effectiveness = pokemonData.calculateTypeEffectiveness(
    playerInfo.types,
    enemyInfo.types
  );
  
  return {
    enemy: {
      ...enemyPokemon,
      info: enemyInfo,
      tierRating
    },
    player: {
      ...playerPokemon,
      info: playerInfo
    },
    effectiveness,
    timestamp: Date.now()
  };
}

// REST API endpoints
app.get('/api/status', (req, res) => {
  res.json({
    connection: connectionStatus,
    hasBattleData: battleState !== null
  });
});

app.get('/api/battle', (req, res) => {
  res.json(battleState);
});

// Socket.IO for real-time updates
io.on('connection', (socket) => {
  console.log('Web client connected');
  
  // Send current state
  socket.emit('connection-status', { status: connectionStatus });
  if (battleState) {
    socket.emit('battle-update', battleState);
  }
  
  socket.on('disconnect', () => {
    console.log('Web client disconnected');
  });
});

// Start servers
tcpServer.listen(TCP_PORT, () => {
  console.log(`TCP server listening on port ${TCP_PORT} for BizHawk connection`);
});

server.listen(HTTP_PORT, () => {
  console.log(`HTTP server listening on port ${HTTP_PORT} for web clients`);
});
